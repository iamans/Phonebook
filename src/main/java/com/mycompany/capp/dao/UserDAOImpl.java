// Note: implementation for save method 

package com.mycompany.capp.dao;

import com.mycompany.capp.rm.UserRowMapper;
import com.mycompany.contact.domain.User;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

/**
 *
 * @author 55ans
 */

@Repository
public class UserDAOImpl extends BaseDAO implements UserDAO {

    @Override
    public void save(User u) {
     String Sql = "INSERT INTO user (name,phone,email,address,loginName,password,role,loginStatus)"
             + "VALUES(:name,:phone,:email,:address,:loginName,:password,:role,:loginStatus)";  
     
     
   //now gonna bind all the values
     
     Map m = new HashMap();
     m.put("name",u.getName());
     m.put("phone",u.getPhone());
     m.put("email",u.getEmail());
     m.put("address",u.getAddress());   
     m.put("loginName",u.getLoginName());
     m.put("password",u.getPassword());
     m.put("role",u.getRole());
     m.put("loginStatus",u.getLoginStatus());
     
     // using key holder object  to bind the value which is autoincrementes and generated by database
     
        KeyHolder kh = new GeneratedKeyHolder();
        SqlParameterSource ps = new MapSqlParameterSource(m);
       super.getNamedParameterJdbcTemplate().update(Sql, ps,kh);
       Integer userId = kh.getKey().intValue();
       u.setUserId (userId);
    
    }
   

    @Override
    public void update(User u) {
        
        //dont forget to keep space after user
     // while breaking query keep space before "(double inverted commas)
        
       String sql = "UPDATE user "     
               + "SET name=:name,"
               + "phone=:phone,"
               + "email=:email,"
               + "address=:address,"
               + "role=:role,"
               + "loginStatus=:loginStatus "
               + "WHERE userId=:userId";
       
       
       
      //now binding value
     Map m = new HashMap();
     m.put("name",u.getName());
     m.put("phone",u.getPhone());
     m.put("email",u.getEmail());
     m.put("address",u.getAddress());   
     m.put("role",u.getRole());
     m.put("loginStatus",u.getLoginStatus());
     m.put("userId", u.getUserId());
     getNamedParameterJdbcTemplate().update(sql, m);
     
    }

    
    
    
    //delete using user object
    @Override
    public void delete(User u) {
        this.delete(u.getUserId());
    }

    
    
    //delete using userId
    @Override
    public void delete(Integer userId) {
      
     String sql = "DELETE FROM user WHERE userId=?";   
      getJdbcTemplate().update(sql,userId);
        
    }

    
    
    //For one p/k only one record  will be in database 
    @Override
    public User findById(Integer userId) {
     String sql = "SELECT userId,name,phone,email,address,loginName,role,loginStatus FROM user WHERE userId=?";
     
  User u =   getJdbcTemplate().queryForObject(sql, new UserRowMapper(),userId);
       
  return u;
    }

    @Override
    public List<User> findAll() {
     String sql = "SELECT userId,name,phone,email,address,loginName,role,loginStatus FROM user";
   
     /*
     List<User>users =getJdbcTemplate().query(sql,new UserRowMapper());
    return users;
   */
     return getJdbcTemplate().query(sql,new UserRowMapper());
    
    }

    @Override
    public List<User> findByProperty(String propname, Object propValue) {
      String sql = "SELECT userId,name,phone,email,address,loginName,role,loginStatus FROM user WHERE "+propname+"=?";  
   
      return getJdbcTemplate().query(sql, new UserRowMapper(),propValue);
    }
    
    
}
